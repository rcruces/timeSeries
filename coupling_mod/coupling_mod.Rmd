---
title: "Coupling Modulation"
author: "RRC"
output: pdf_document
---

```{r setup, include=FALSE, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(signal) # library for signal analysis
library(viridis) # colormaps
library(signal, warn.conflicts = F, quietly = T) # signal processing functions
library(oce, warn.conflicts = F, quietly = T) # image plotting functions and nice color maps
library(spectral) 
library(seewave) # huilbert transformation
library(pracma) # findpeaks
```

```{r functions, include=FALSE, echo=FALSE, message=FALSE}
angle <- function(z) {
    #   Phase angle.
    #   angle(H) returns the phase angles, in radians, 
    #   of a matrix withcomplex elements.  
    # The angle function is simply defined as atan2(Im(z), Re(z))
        z <- atan2(Im(z), Re(z))
    return(z)
}
```
  

## 1. Read the data
```{r, echo=FALSE, message=FALSE, warning=FALSE}
# https://hansenjohnson.org/post/spectrograms-in-r/
P <- function(Path){koti=Sys.getenv("KOTI"); return(paste0(koti,Path))}
Data <- read.table(P("git_here/timeSeries/coupling_mod/Basal.atf"),skip = 10,col.names = c("time","mV"))
```

## Spectrogram of the raw time series  
```{r spectro, echo=FALSE, message=FALSE, warning=FALSE}
Ns <- which(Data$time==1) # Seconds to test

# Local Field Potential Signal (LFP)
LFP <- Data$mV[1:Ns]
LFP.t <- Data$time[1:Ns]

# Sampling frecuency (Hz)
Fs <- 5000

# create spectrogram
spec <- specgram(x = LFP,
                n = min(256, length(LFP)), # size of the fourier window
                Fs = Fs,                   # Sample rate, Hz
                # window = window,
                # overlap = overlap
                )

# discard phase information
Phase <- abs(spec$S)

# normalize
Phase <- Phase/max(Phase)

# convert to dB
Phase <- 10*log10(Phase)

# config time axis
Time <- spec$t

# plot spectrogram
imagep(x = Time,
       y = spec$f,
       z = t(Phase),
       col = magma,
       ylab = 'Frequency [Hz]',
       xlab = 'Time [s]',
       drawPalette = T,
       decimate = F
)
```
  
## PCA of the raw time series  
```{r pca, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8}

```
  
  
## Filtering of the data
```{r filters, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8}
# Nyquist ratio
NyFq <- Fs/2

# Inrerior gamma limit
Cut20 <- 20/NyFq
# Superior gamma limit
Cut40 <- 40/NyFq

# Inferior theta limit
Cut4 <- 4/NyFq
# Superior theta limit
Cut11 <- 11/NyFq

# Butterworth filter
# Coeficientes Butterworth para gamma 
# [Bg,Ag]=butter(4,[Cut20 Cut40])
gamma.butter <- butter(4, W = c(Cut20, Cut40))

# Coeficientes Butterworth para theta
# [Bt,At]=butter(2,[Cut4 Cut11])
theta.butter <- butter(2, W = c(Cut4, Cut11))

# Forward And Reverse Filter (Zero-phase digital filtering)
Gamma <- filtfilt(gamma.butter, LFP)
# Filtro sin delay theta
Theta <- filtfilt(theta.butter, LFP)

# ----------------------------------------------------------- #
# plot settings
col.theta <- "coral3"
col.gamma <- "cornflowerblue"
time.crop <- LFP.t[1:Ns]
par(mfrow=c(2,1))

# Raw data plot
plot(time.crop, Data$mV[1:Ns], type='l', bty='n', xlab = 'Time (s)', ylab='mV', main='LFP raw data', col='gray45')
abline(h=0, lty=2, col="red4", lwd=1)
# Raw data plot, GAMMA & THETA
plot(time.crop, Data$mV[1:Ns], type='l', bty='n', xlab = 'Time (s)', ylab='mV', main='LFP raw data, Filtered gamma and theta', col='gray45')
abline(h=0, lty=2, col="red4", lwd=1)
lines(time.crop,Gamma[1:Ns], col=col.gamma, lwd=2)
lines(time.crop, Theta[1:Ns], col=col.theta, lwd=2)
legend("bottomleft", c("Gamma", "Theta"),
       col = c(col.gamma, col.theta), fill = NA, border = NA, text.col = c(col.gamma, col.theta), lty=1, box.col = NA, bg = NA)

```
  
  
```{r filters.plot, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8}
par(mfrow=c(2,1))
# GAMMA over THETA
plot(time.crop, Gamma[1:Ns], type='l', bty='n', xlab='Time (s)', ylab='mV', main="Gamma peaks over theta cycles\n(filter)", col=col.gamma)
abline(h=0, lty=2, col="red4", lwd=1)
lines(time.crop, Theta[1:Ns], col=col.theta, lwd=2)

# SCALED - Gamma peaks over theta
plot(time.crop, Gamma[1:Ns], type='l', bty='n', xlab='Time (s)', ylab='', main="Gamma peaks over theta cycles\n(filtered & scaled)", col=col.gamma, yaxt = "n")
axis(side = 2, col = col.gamma, col.ticks = col.gamma, col.axis=col.gamma)
abline(h=0, lty=2, col="red4", lwd=1)
par(new = TRUE)
plot(time.crop, Theta[1:Ns], type = "l", xaxt = "n", yaxt = "n",bty='n',
     ylab = "", xlab = "", col = col.theta, lty = 1, lwd=1.5)
axis(side = 4, col = col.theta, col.ticks = col.theta, col.axis=col.theta)
legend("topleft", c("Gamma", "Theta"),
       col = c(col.gamma, col.theta), fill = NA, border = NA, text.col = c(col.gamma, col.theta), lty=1, box.col = NA, bg = NA)
```
  
  
```{r hilbert, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8}
# -------------------------------------------------------------- #
# Gamma processing
require(seewave)
thr <- -0.5 #threshold for peak detection (WHY???)

# 1. Hilbert transformation
hilGamma <- hilbert(Gamma, Fs) # from seewave

# 2. Extraction of the instant phase oin radians
angGamma <- angle(hilGamma)

# 3. Expands the previously calculated angles into a full circle (2*pi)
angGamma <- angGamma-2*pi*floor(angGamma/(2*pi))

# 4. Invertion of the signal in order to find 90 =0 rad
negGam <- -1*angGamma

# 5. Find peaks
subGamma <- findpeaks(as.numeric(negGam), minpeakheight=thr)
TotalGPeaks <- dim(subGamma)[1]

# -------------------------------------------------------------- #
# Theta processing
# 1. Hilbert transformation
Htheta <- hilbert(Theta, Fs) # from seewave

# 2. Extraction of the instant phase oin radians
angTheta <- angle(Htheta)

# 3. Expands the previously calculated angles into a full circle (2*pi)
angTheta <- angTheta-2*pi*floor(angTheta/(2*pi))

# 4. Invertion of the signal in order to find 90 =0 rad
negThe <- -1*angTheta

# 5. Find peaks
subTheta <- findpeaks(as.numeric(negThe), minpeakheight=thr)
TotalTPeaks <- dim(subTheta)[1]

# TOTAL GAMMA per THETA
GpeakPerTheta <- TotalGPeaks/TotalTPeaks
print(paste('Gamma peaks per Theta cycle:', GpeakPerTheta))

# -------------------------------------------------------------- #
# QC plots of the Hilbert transform and peak detection
# Hilbert plots
par(mfrow=c(2,2))
plot(Htheta, type='l', col=col.theta, main="Theta Hilbert", bty="n")
plot(hilGamma, type='l', col=col.gamma, main="Gamma Hilbert", bty="n")
 
# Peaks Theta
plot(LFP.t ,negThe, type='l', bty="n", col=col.theta, ylab="Time", main=paste("Total Theta peaks:", TotalTPeaks))
points(LFP.t[subTheta[,2]], subTheta[,1] , pch=19, col="gray45", cex=1)

# Peaks Gammma
plot(LFP.t ,negGam, type='l', bty="n", col=col.gamma, ylab="Time", main=paste("Total Gamma peaks:", TotalGPeaks))
points(LFP.t[subGamma[,2]], subGamma[,1] , pch=19, col="gray45", cex=1)

# Save as matlab variables
# library(R.matlab)
# writeMat("/Users/rcruces/git_here/timeSeries/coupling_mod/LFP_data.mat",
#          LFP=LFP, Time=LFP.t, Rgamma=Gamma, Rtheta=Theta, Rnegamma=negGam)
```


# `matlab` code
```{matlab}
# -------------------------------------------------------------- #
# I AM HERE
# encuentra el angulo de theta donde se encuentra los picos de gamma
gammaTheta=angTheta(subGamma);
figure(1)
subplot(1,2,1)
rose(gammaTheta)

# -------------------------------------------------------------- #
# Vector length 
# C?LCULO DE LA LONGITUD DEL VECTOR
disp('Vector unitario medio:')
u=sum(exp(1i*gammaTheta));# calcula el vector unitario medio (f?rmula de Euler)
disp('Longitud total del vector Normalizado:')
absVecLength=abs(u)/TotalGPeaks; # obtiene el radio resultante (r) normalizado entre 0 y 1
figure(1)
subplot(1,2,2)
compass(u/TotalGPeaks)
 
# C?LCULO DEL ANGULO DEL VECTOR GAMMA OVER THETA (gammaTheta)
disp('?ngulo del vector en pi valores:')
AngGammaTheta=angle(u); #  Calcula el angulo del vector normalizado
disp('?ngulo del vector en radianes:')
angGammaTheta_Rad=AngGammaTheta-2*pi*floor(AngGammaTheta/(2*pi)); # Expande el angR a 2pi
 
clf; clf;
 
#  Gamma Envelope
 
#  Nombra LFP a la variable que contiene el registro de campo
#  Nombra time a la variable que contiene el tiempo de registro
 
# C?LCULO DE LA ENVOLVENTE
[envolvente0,~]=envelope(gamma,100,'peak');# c?lculo de la envolvente ajustada al pico con 100 puntos de resoluci?n
envolvente=envolvente0-mean(envolvente0);# ajuste de la envolvente a la basal
 
# TRANSFORMADA DE FOURIER DE AMBAS OSCILACIONES
Fs=5000;# Frecuencia de sampleo (=n? de puntos/tiempo de registro (s))
L=length(envolvente);# c?lulo del tama?o de la variable
NFFT=2^nextpow2(L);# optimizaci?n del tama?o de las variables para la FFT (el m?tiplo de 2 mayor m?s cercano)
Y1=fft(LFP,NFFT)/L;# transformada ponderada de Fourier para LPF
espectro1=2*abs(Y1(1:NFFT/2+1));# obtenci?n de la mitad de los valores absolutos del espectro espejo de LFP
Y2=fft(envolvente,NFFT)/L;# transformada ponderada de Fourier para la envolvente
espectro2=2*abs(Y2(1:NFFT/2+1));# obtenci?n de la mitad de los valores absolutos del espectro espejo de la envolvente
filter=ones(1,100)/100;# filtro de 100 puntos para suavizar ambos espectros
espectro1=conv(espectro1,filter,'same');# convoluci?n de LFP con el filtro
espectro2=conv(espectro2,filter,'same');# convoluci?n de la envolvente con el filtro
f=Fs/2*linspace(0,1,NFFT/2+1);# obtenci?n del rango de frecuencias a trav?s de la frecuencia de sampleo
 
# C?LCULO DE LA POTENCIA DE LA ENVOLVENTE
fr5=5;
tmp=abs(f-fr5);
[~, inx4]=min(tmp);
fr10=10;
tmp=abs(f-fr10);
[~, inx10]=min(tmp);
 
fr20=20;
tmp=abs(f-fr20);
[~, inx20]=min(tmp);
fr80=60;
tmp=abs(f-fr80);
[~, inx80]=min(tmp);
 
for n=inx4:inx10
    Area=(espectro2(n)+espectro2(n+1))/2*(f(n+1)-f(n));
end
GenvPow=sum(Area);
 
# C?LCULO DEL PICO M?XIMO DE FRECUENCIA
cerotes=zeros(length(espectro2(1:inx4-1)),1);# prepara un vector de 0 para aislar theta
newespectro2=vertcat(cerotes,espectro2(inx4:inx10));# concatena los ceros al rango de theta
[~,inxMaxE]=max(newespectro2);
GenvMax=f(inxMaxE);
 
cerotes=zeros(length(espectro1(1:inx20-1)),1);# prepara un vector de 0 para aislar gamma
newespectro1=vertcat(cerotes,espectro1(inx20:inx80));# concatena los ceros al rango de gamma
[~,inxMaxG]=max(newespectro1);
GMax=f(inxMaxG);
 
 
# GR?FICAS
subplot(2,1,1)
plot(f,espectro1,f,espectro2)
axis([0 80 0 0.005]) # de 0 a 80 Hz y de 0 a 15e-3 mV2
subplot(2,1,2)
plot(time,gamma,time,envolvente0,time,theta)
axis([0 1 -0.35 0.35]) # de 0 a 1 s y de -0.1 a 0.1 mV
shg
 
#  Cross-correlation Gamma Envelope-Theta
[acor,lag] = xcorr(envolvente,theta,'coeff');      # correlacion de las senyales
 
 
 
[cor,I] = max((abs(acor)));# coeficiente de correlacion entre ambas senales 
Peaklag = lag(I);#  Posicicion del pico maximo 
timeDiff = Peaklag/Fs; #  lag en s del pico maximo
Peaklagms = timeDiff*1000; #  Peak lag en ms.
 
plot(lag/Fs,acor)
axis([-0.5 0.5 -0.6 0.6])
shg
 
# Autocorrelation of gamma signal and Rhythmicity
[acor,lag] = xcorr(gamma,500);      # correlacion de las senyales
Nacor = acor/max(acor); # Normaliza el maximo de autocorrelation
halfcor = Nacor(fix((length(acor)/2)):end); # mitad de la correlacion
halftime = (lag(fix((length(lag)/2)):end))/Fs;# time of the corresponding lag in sec
 
cor1 = halfcor; # redefine la variable halfcor
 
peaks = findpeaks(cor1);    # picos
troughs = findpeaks(-cor1); # valles
 
A = peaks(2) + 1;        # identificaci?n del primer pico
B = - troughs(1) + 1;  # identificaci?ndel segundo valle
 
Cr=(A-B)/(A+B);
 
# plot(halftime,halfcor)
# axis([0 0.1 -1  1])
# shg
 
```

## Measurements to implement
Phase syncrony (PS) https://www.rdocumentation.org/packages/synchrony/versions/0.3.8/topics/phase.sync
Cross-frequenct phase synchrony (CFS)
Phase-amplitude coupling (PAC)
PAC-t https://github.com/muntam/TF-PAC
https://www.nature.com/articles/s41598-019-48870-2

1.Amplitud y frecuencia de la senal envolvente
1. Acoplamiento de la senal enviolmente cin ka senak principla
1. Acoplamiento de la senal evolvent eocn los potenciales de accion  

# References  
Cross-Frequency Phase–Phase Coupling between Theta and Gamma Oscillations in the Hippocampus
Mariano A. Belluscio, Kenji Mizuseki, Robert Schmidt, Richard Kempter and György Buzsáki
Journal of Neuroscience 11 January 2012, 32 (2) 423-435; DOI: https://doi.org/10.1523/JNEUROSCI.4122-11.2012
https://www.jneurosci.org/content/32/2/423  
https://towardsdatascience.com/four-ways-to-quantify-synchrony-between-time-series-data-b99136c4a9c9 
  
  
# Further resources  
1. (R for Matlab users)[http://mathesaurus.sourceforge.net/octave-r.html]
1. mat2r from matconv
1. (Numpy for R users)[http://mathesaurus.sourceforge.net/r-numpy.html]
1. (Fourier Transform: A R tutorial)[http://www.di.fc.ul.pt/~jpn/r/fourier/fourier.html]
